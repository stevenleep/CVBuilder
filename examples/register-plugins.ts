/**
 * 示例插件注册
 */

import { IEditorContext } from '../src/core/context/EditorContext'
import { AIAssistantPlugin } from './plugins/AIAssistantPlugin'
import { WatermarkPlugin } from './plugins/WatermarkPlugin'
import { DataValidatorPlugin } from './plugins/DataValidatorPlugin'

export interface IPluginsConfig {
  aiAssistant?: {
    enabled: boolean
    apiKey?: string
    model?: string
  }
  watermark?: {
    enabled: boolean
    text?: string
    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center'
    opacity?: number
  }
  dataValidator?: {
    enabled: boolean
  }
}

const defaultPluginsConfig: IPluginsConfig = {
  aiAssistant: {
    enabled: false,
  },
  watermark: {
    enabled: false,
    text: 'Generated by CVBuilder',
    position: 'bottom-right',
    opacity: 0.3,
  },
  dataValidator: {
    enabled: true,
  },
}

export async function registerAllPlugins(context: IEditorContext, config: IPluginsConfig = {}) {
  const finalConfig = {
    ...defaultPluginsConfig,
    ...config,
  }

  const plugins: {
    aiAssistant?: AIAssistantPlugin
    watermark?: WatermarkPlugin
    dataValidator?: DataValidatorPlugin
  } = {}

  if (finalConfig.aiAssistant?.enabled) {
    const aiPlugin = new AIAssistantPlugin({
      apiKey: finalConfig.aiAssistant.apiKey || process.env.VITE_OPENAI_API_KEY,
      model: finalConfig.aiAssistant.model || 'gpt-3.5-turbo',
    })

    await aiPlugin.activate({
      extensionService: context.extensionService,
      commandService: context.commandService,
      notificationService: context.notificationService,
      hookService: context.hookService,
      eventBus: context.eventBus,
    })

    plugins.aiAssistant = aiPlugin
  }

  if (finalConfig.watermark?.enabled) {
    const watermarkPlugin = new WatermarkPlugin({
      text: finalConfig.watermark.text || 'Generated by CVBuilder',
      position: finalConfig.watermark.position || 'bottom-right',
      opacity: finalConfig.watermark.opacity || 0.3,
      fontSize: 12,
      color: '#999999',
      enabled: true,
    })

    await watermarkPlugin.activate({
      middlewareService: context.middlewareService,
      hookService: context.hookService,
      notificationService: context.notificationService,
      eventBus: context.eventBus,
    })

    plugins.watermark = watermarkPlugin
  }

  if (finalConfig.dataValidator?.enabled) {
    const validatorPlugin = new DataValidatorPlugin()

    await validatorPlugin.activate({
      hookService: context.hookService,
      validationService: context.validationService,
      notificationService: context.notificationService,
      eventBus: context.eventBus,
    })

    plugins.dataValidator = validatorPlugin
  }

  return plugins
}

export async function unregisterAllPlugins(plugins: Record<string, any>) {
  for (const [, plugin] of Object.entries(plugins)) {
    if (plugin && typeof plugin.deactivate === 'function') {
      await plugin.deactivate()
    }
  }
}
